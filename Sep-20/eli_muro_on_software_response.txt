Ive been having this struggle where I am debating, with myself primarily, whether or not to get into the nuts and bolts or particles and atoms of programming and software. I often lead myself down these paths to the source of something forgetting why or how I got interested in the thing in the first place. Theres this great quote/meme floating around the internet that describes the struggle using music as an example:

 “I thought using loops was cheating, so I programmed my own using samples. I then thought using samples was cheating, so I recorded real drums. I then thought that programming it was cheating, so I learned to play drums for real. I then thought using bought drums was cheating, so I learned to make my own. I then thought using pre-made skins was cheating, so I killed a goat and skinned it. I then thought that that was cheating too, so I grew my own goat from a baby goat. I also think that is cheating, but I’m not sure where to go from here. I haven’t made any music lately, what with the goat farming and all.”

I have always felt intuitively that learning how a tool works ,at a fundamental level, if you are going to use it is the best route and i found this text to reflect some of the ideas. I couldn’t help but think about the two different bits of software that I have been using, openFrameworks and touch designer. Alot of my fellow artists back home are learning touch designer and I feel that node based programming is a bit limiting ( and it can be expensive) although it is a quicker solution that learning from the basics first. But this seems to be a problem in many types of technology, where people value the convenience over anything else and don’t really care to consider the cost of their convenience.

I wonder what it would look like to see the flip side of your convenience when you use a tool? This reminds me of Marshall Mcluhan when he talks about tools and how they do what we design them to do but at the same time the exact opposite. In this case it could be said that a tool like touch designer makes creating interactive projects easy and accessible but prevents you from understanding the underlying structures that the tool is composed of, and what limits those structures impose on you or others.

Like Kyong Chun  says “ In the name of programming as a question of flow, is itself giving way to data abstraction which views programming as a question of interrelated objects and hides far more than the machine. …data abstraction is all about forgetting” I think often times when  we use a service or piece of technology and we get some level of ease or convenience, we are shielded, through abstraction, the inconvenience that someone else receives.

